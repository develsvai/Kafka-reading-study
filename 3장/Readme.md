# 3.1 프로듀서

카프카 를 큐 로서 사용하든, 메시지 버스, 데이터 저장 플랫폼으로 사용하든 간에 카프카를 사용할떄는 카프카에 데이터를 쓸 때 사용하는 프로듀서 나 읽어 올때 사용하는 컨슈머, 혹은 두가지 기능 모두를 수행하는 애플리케이션을 생성해야 한다. 

애플리케이션이 카프카에 메시지를 써야 하는 상황에는 여러가지 가 있다. 감사 혹은 분석을 목적으로 한 사용자 행동기록, 성능 메트릭 기록 ,로그 메시지 저장,스마트 가전 에서의  정보 수집, 다른 애플리케이션 과의  비동기적 통신수행, 임의의 정보를 데이터 베이스에 저장하기 전 버퍼링 등이 있다.

프로듀서는 보통 카프카 프로듀서 API 와 그것으로 구성된 애플리케이션을 말함,

프로듀서는 브로커에 특정 토픽(혹은 파티션 영역까지)을 지정하여 메시지를 전달하는 역할을 담당
![1 1](https://github.com/develsvai/Kafka-reading-study/assets/125961256/0a150697-a4ce-4d7b-8ef1-e8bd3739524b)


# 3.2 프로듀서 객체 생성

카프카에 메시지를 쓰려면 원하는 속성을 지정하여 프로듀서 객체 를 생성해야 한다. 카프카 프로듀서는 3개의 필수 속성 값을 가짐 

bootstrap.servers- 브로커의 host:port 목록 

*프로듀서 가 연결 성공후 추가 정보를 받아 오기 때문에 모든 브로커를 포함 하지 않아두 됨*

key.serializr-카프카에 쓸 레코드의 키 값을 직렬화 하기 위해 사용하는 시리얼 라이저 클래스의 이름

브로커는 메시지의 키값, 벨류값으로 바이트 배열을 받는데 프로듀서 인터페이스는 자바 객체 를 키혹 은 밸류 로 전송하능 하도록 매개변수 화 된 타입 을 지원하는데 이 때문에 바이트 배열로 변환하는 클래스 의 이름을 알려주어야 한다.

value.serializer- 벨류값을 직렬화 하기 위한 시리얼 라이저 클래스 이름

### 프로듀서를 통해 전달되는 메시지의 구조(프로듀서 레코드 라 함)

- 토픽 (Topic)
- 토픽 중 특정 파티션 위치 (Partition)
- 메시지 생성 시간 (Timestamp)
- 메시지 키 (Key)
- 메시지 값 (Value)

# 3.3메지지 전송
![1 2](https://github.com/develsvai/Kafka-reading-study/assets/125961256/8cc609a0-dc8d-4031-9fa8-d820423e279a)



1. 직렬화 (Serializer)
2. 파티셔닝 (Partitioner)
3. 메시지 배치 (Record Accumulator)
4. 압축 (Compression)
5. 전달 (Sender)

카프카에 메시지를 쓰는 작업 ProducerRecord 에 객체 를 생성함으로써 시작된다. 여기서 레코드가 저장될 토픽과 밸류 지정은 필수 사항이지만, 키와 파티션 지정은 선택사항이다.

일단 ProducerRecord 를 전송하는 api를 호출했을 때(send 메소드) 프로듀서 가 가장 먼저 하는 일은 키와 값 객체가 네트워크 상에서 전송될 수 있도록 직렬화 해서 바이트 배열로 변환하는 과정이다. 

직렬화 과정을 마친 메시지는 파티셔너를 통해 **토픽의 어떤 파티션에 저장될지 경절하게 되는데** 이 과정을 파티셔닝(Partitioning)이라 한다.

만약 파티션을 명시적으로 지정하지 않았으면 해당 데이터를 파티셔너 로 보내 파티션을 결정하게 하는데 그 기준은 보통 프로듀서 레코드 객체의 키 값이 며 파티션으로 전송될 레코드들을 모든 레코드 배치 에 추가하고  **프로듀서는 지정된 만큼 메시지를 저장했다가 한 번에 브로커로 전달한다.**

브로커는 메시지를 받았을시 응답을 들려주게 되어 있으며 성공일 경우 토픽,파티션, 레코드의 오프셋을 담은 레코드 메타 데이터를 반환 한다. 

# 3.3.1 동기적 메시지 전송

카프카는 언제나 비동기적으로 동작한다. 

1.프로듀서 는 프로듀서 레코드 객체를 받으므로 이객체 를 생성하는 것에서 부터 시작한다.

2.프로듀서 레코드를 전송하기 위해 send 메소드를 사용한다.

3.send 메소드는 레코드 메타데이터를 포함한 자바 feature 객체를 리턴한다. 

4.카프카로 부터 응답이 올떄 까지 대기 하기 위해 feature.get() 메소드를 사용하고 , 응답이 제대로 오지 않을 경우 예외 처리를 한다. 

5.메시지 전송 전에  직렬화 에러가 발생하면 serializztionException 예외를, 버퍼가 가득 찰경우 TimeoutException을 , 스레드에 인터럽트 가 걸리는 경우 intteruptException 예외를 발생 시킨다.

 

# 3.3.2 비동기적 메시지 전송

카프카에 쓰이는 모든 메시지 에 대해서 응답을 받을 필요는 없다 대부분의 애플리케이션에는 메타 데이터가 필요 없기 때문이다. 

비동기적 전송은 메타 데이터 가 필요한 경우에만 메타데이터 전송 콜백 클래스를 구현하여  프로듀서가 레코드를 전송할때 콜백을 지정할수 있도록 한다. 

# 3.5 시리얼 라이저

프로듀서 를 설정할때 필수적으로 시리얼 라이저를 설정 해야한다. 카프카는 여려 시리얼 라이저를 지원하는데 정수값을 직렬화 하는 integger 시리얼 라이저, String시리얼 라이저, Byte시리얼 라이저 등이 있다 

위에서 설명 한 것 외에 정수나 문자열이 아닌경우 선택지 는 2가지가 있다. 

1. 레코드를 생성하기 위해 에이브로, 스리프트, 프로토버프, 와 같은 범용 직렬화 라이브러리 를 사용할 수  있다.
2. 사용하고 있는 객체를 직렬화 하기 위해 커스텀 직렬화 로직을 작성한다. 

# 3.6 파티션

우리가 생성한 프로듀서 레코드 객체는 토픽,키,벨류 의 값을 포함한다. 카프카의 메시지는 키-벨류 순서쌍 이라고 할 수 있는데, 키 값이 null이여도 프로듀서 레코드 객체를 생성 할 수있다. 

기본 파티셔너에 키값이 존재할 경우 키값을 해싱 하여 그에 대응하는 파티션을 할당한다.  

하지만 키 값이 null인 경우 레코드는 현재 사용 가능한 토픽의 파티션 중 하나에 랜덤하게 저장된다. 

키값이 null인 접착성 처리를 위해 라운드 로빈 알고리즘이 사용된다.

# 접착성 처리

- 라운드 로빈 스케줄링(Round Robin Scheduling, RR)은 시분할 시스템을 위해 설계된 선점형 스케줄링의 하나로서, 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위(Time Quantum/Slice)로 CPU를 할당하는 방식의 CPU 스케줄링 알고리즘입니다.

(==) 같은말로, 컴퓨터 운영에서, 컴퓨터 자원을 사용할 수 있는 기회를 프로그램 프로세스들에게 공정하게 부여하기 위한 한 방법으로서, 각 프로세스에 일정시간을 할당하고, 할당된 시간이 지나면 그 프로세스는 잠시 보류한 뒤 다른 프로세스에게 기회를 주고, 또 그 다음 프로세스에게 하는 식으로, 돌아가며 기회를 부여하는 운영방식이라 풀어 말할 수 있겠습니다.

프로세스 의 순서를 결정할 때 보통 우선순위를 지정하여 cpu자원의 우선권을 주는데 라운드 로빈은 우선 순위 없이 프로세스가 할당된 시간 순서대로 cpu 자원 사용의 우선권을 준다는 말 

프로듀서에서 라운드 로빈 알고리즘은 각 파티션 별로 저장되는 메시지 개수의 균형을 위해 사용됨 

키값이  존재 하는 경우 키값에 따라 파티션이 할당 되고 키 값이 null인 경우에 라운드 로빈 알로리즘 을 통해 파티션이 결정된다. 하지만 이경우 하나의 문제가 존재하게 되는데 메시지의 개수 에 따라 데이터가 저장되지 않는 파티션이 생긴다는것이다. 

라운드 로빈 을 사용할시 배치에 메시지가 다 채워지지 못하고 전송 되는 것이기 때문에 파티션에 메시지가 저장 안되는것이 아님 지연시간이 길어지는 것 일 뿐

그래서 잡착성 처리 를 통해 모든 파티션에 데이터가 균등하게 저장되도록 할수 있다. 

# 3.7 헤더

프로듀서 레코드 는 키값, 벨류 값 이외에도 헤더를 포함 할 수 있다. 레코드 헤더는 카프카 레코드의 키/벨류 값을 거드리지 않고 추가 메타 데이터를 심을 때 사용한다. 

헤더의 주요 용도 중 하나는 메시지의 전달 내역을 기록 할때 사용한다. 데이터가 생성된 곳의 정보를 헤더에 저장해 두면,

메시지를 파싱할 필요 없이 헤더에 심어진 정보만으로 메시지를 라우팅 하거나 출처를 추적 할 수 있는 것이다. 

# 3.8 인터셉터(Producer intercepter Class)

이따금 카프카 클라이언트 의 코드를 고치지 않으면서 그 작동을 변경해야 하는 경우가 있다. 

모든 애플리케이션에 동일한 동작을 집어 넣거나 원래 코드를 사용할 수 없는 경우가 그 것이다. 

이때 사용할 수 있는 것이 인터셉터 이다.  

config

ack = all경우

메시지가 모든 isr 에 전달 된 뒤에야 브로커로 부터 응답을 받는다 x

32p min.insunc
